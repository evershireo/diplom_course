# Расширенный скриптинг

В базовом курсе мы уже писали простые скрипты, или сценарии командной строки.

Сценарии командной строки — это наборы тех же самых команд, которые можно вводить с клавиатуры, собранные в файлы и объединённые некоей общей целью. При этом результаты работы команд могут представлять либо самостоятельную ценность, либо служить входными данными для других команд. Сценарии — это мощный способ автоматизации часто выполняемых действий.

## Потоки, перенаправление ввода, вывода и ошибок

В Linux, как и в большинстве UNIX-подобных систем, управление потоками ввода, вывода и ошибок осуществляется с помощью стандартных потоков. Эти потоки являются основой для работы с файлами и устройствами и часто используются при разработке программ, сценариев и командной обработке.

### Стандартный ввод (Standard Input, stdin)

Стандартный поток ввода используется для получения данных, введенных пользователем или полученных из другого источника данных (например, файла или другого процесса).

### Стандартный вывод (Standard Output, stdout)

Используется для вывода данных программой. Когда программа пишет что-то в stdout, это обычно отображается в терминале.

### Стандартный поток ошибок (Standard Error, stderr)

Стандартный поток ошибок используется для вывода сообщений об ошибках и диагностики. Он отделен от стандартного вывода, что позволяет обрабатывать и направлять их независимо.

В Linux можно перенаправлять потоки с помощью операторов оболочки. Это позволяет, например, записывать вывод программы в файл или передавать его другому процессу.

Символ `>` используется для записи в файл, `>>` для добавления в файл. При использовании символа `>` содержимое файла **будет перезаписано**

```bash
  # Записывает вывод команды в файл output.txt
  $ ls
  file1.txt file2.txt file3.txt
  $ ls > output.txt
  $ cat output.txt
  file1.txt file2.txt file3.txt
```

```bash
  # Добавляет вывод команды в конец файла output.txt
  $ cat output.txt
  First line
  Second line
  $ echo "Hello" >> output.txt
  $ cat output.txt
  First line
  Second line
  Hello
```  

Символ `<` используется для перенаправления потока ввода, например, для чтения из файла.

```bash
  # Пример использования файла в качестве входных данных для программы
  $ cat input.txt
  2 3 1
  $ sort < input.txt
  1 2 3
```

Символы `2>` и `2>>` используются для перенаправления потока ошибок. Первый используется для перезаписи файла, второй для добавления строк в файл

```bash
  # Записывает ошибки в файл errors.txt
  $ find / -name testfile.txt
  /root/: Access denied
  /home/user/testfile.txt

  $ find / -name testfile.txt 2> errors.txt
  /home/user/testfile.txt
  $ cat errors.txt
  /root/: Access denied
```

Перенаправление обоих потоков (вывод и ошибки) в один файл:

```bash
  $ find / -name testfile.txt > output.txt 2>&1
  $ cat output.txt
  /root/: Access denied
  /home/user/testfile.txt
```

Также допустимо использовать символ `&>`

```bash
  $ find / -name testfile.txt &> output.txt
  $ cat output.txt
  /root/: Access denied
  /home/user/testfile.txt
```

Кроме того, потоки можно разделять

```bash
  $ find / -name testfile.txt > output.txt 2> error.txt
  $ cat output.txt
  /home/user/testfile.txt
  $ cat error.txt
  /root/: Access denied
```

Кроме потоков, в Linux существуют конвейеры (pipes).

Конвейеры обозначаются символом `|` позволяют передавать выход одного процесса как вход в другой.

```bash
# Программа ls передает свой вывод программе grep
$ ls
file1.txt file2.csv file3.docx
$ ls | grep "txt"
file1.txt
```

При помощи перенаправления потоков ввода-вывода и конвейеров можно строить довольно сложные команды, например, при помощи одной записи можно решить следующие 4 задачи

1. Найти все файлы в текущей директории и поддиректориях.
2. Отфильтровать только те файлы, в именах которых содержится конкретное слово, например, "example".
3. Показать количество таких файлов.
4. Если возникают ошибки (например, ошибки доступа к каким-то поддиректориям), записать их в отдельный файл.

```bash
find . -type f 2> errors.log | grep "example" | wc -l
```

1. `find . -type f 2> errors.log`:
   - `find . -type f`: Команда `find` ищет все файлы (-type f) начиная с текущей директории (.).
   - `2> errors.log`: Любые ошибки, возникающие при выполнении команды `find` (например, ошибки доступа к некоторым директориям), перенаправляются в файл `errors.log`. Это использование стандартного потока ошибок stderr.

2. `| grep "example"`:
   - |: Конвейер передает стандартный вывод от команды `find` в качестве стандартного ввода для команды `grep`.
   - `grep "example"`: `grep` фильтрует строки, содержащие слово "example". Используется стандартный ввод stdin для получения данных от предыдущей команды и стандартный вывод stdout для передачи отфильтрованных строк дальше в конвейер.

3. `| wc -l`:
   - |: Конвейер передает стандартный вывод от команды `grep` в качестве стандартного ввода для команды `wc`.
   - `wc -l`: `wc` подсчитывает количество строк, переданных через стандартный ввод, и выводит это число в стандартный вывод stdout.

Если необходимо написать более сложный конвейер -- не обязательно писать все в одну строку. При необходимости разделить строку на несколько, чтобы при этом интерпритатор считал все как одну команду, можно испольовать символ `\`

Попробуем решить ряд более сложных задач при помощи конвейера

1. Найти все текстовые файлы в директории и ее поддиректориях.
2. Извлечь строки, содержащие слово "ERROR".
3. Упорядочить эти строки по количеству вхождений символа ":", а также по алфавиту, если количество вхождений одинаково.
4. Удалить повторяющиеся строки.
5. Показать только последние 10 строк.
6. Записать информацию о времени выполнения каждой команды в конвейере в отдельный лог-файл.

```bash
# Несмотря на то, что строки разделены, интерпритатор прочитает все это как одну строку
{ time find . -type f -name "*.txt" ; } 2>> pipeline_time.log | \
{ time xargs grep "ERROR" ; } 2>> pipeline_time.log | \
{ time awk '{ print gsub(/:/,":") " " $0 }' ; } 2>> pipeline_time.log | \
{ time sort -k1,1nr -k2 ; } 2>> pipeline_time.log | \
{ time uniq ; } 2>> pipeline_time.log | \
{ time tail -n 10 ; } 2>> pipeline_time.log
```

1. `find . -type f -name "*.txt"`:
   - Ищет все файлы с расширением .txt в текущей директории и поддиректориях.

2. `xargs grep "ERROR"`:
   - Применяет `grep "ERROR"` ко всем файлам, найденным `find`, используя `xargs` для передачи списка файлов.

3. `awk '{ print gsub(/:/,":") " " $0 }'`:
   - Считает количество двоеточий : в каждой строке и выводит это число в начало строки.

4. `sort -k1,1nr -k2`:
   - Сортирует строки по числу двоеточий в порядке убывания (n - числовая сортировка, r - обратный порядок) и, в случае одинакового количества, по содержимому строки в алфавитном порядке.

5. `uniq`:
   - Удаляет дубликаты соседних строк после сортировки.

6. `tail -n 10`:
   - Показывает последние 10 строк результата.

7. Запись времени выполнения: `{ time command ; } 2>> pipeline_time.log`:
   - Каждый этап конвейера обернут в конструкцию с `time`, результаты которой записываются в лог-файл `pipeline_time.log`. Это позволяет оценить, сколько времени заняло выполнение каждой команды.

## Переменные

Если в скрипте необходимо организовать интерактивный ввод, либо сохранить данные для дальнейшей их обработки -- можно использовать переменные. Переменные в Linux делятся по области действия.

1. Глобальные переменные. Это переменные, заданные на системном уровне. Любой процесс может работать с такими переменными. Список переменных определяется в `/etc/profile` для всех пользователей или в `~/.profile` для конкретного пользователя. Пример такой переменной -- $PATH. В данной переменной хранятся пути к исполняемым файлам.
2. Локальные переменные. Это переменные, определенные в рамках текущего сеанса. Например, в командой строке можно написать

```bash
$ $a=1
$ echo $a
1
```

Для того, чтобы сделать переменную доступной любому процессу, необходимо ее "Экспортировать" при помощи команды `export`

```bash
$ export $a=1
$ python3 echo_a.py
1
```

Переменные в скриптах используются аналогично. При помощи переменных в скриптах можно добавить скрипту интерактивности. Для чтения порядковых аргументов используются переменные `$1`, `$2`, `$N`. Если необходимо орагнизовать ввод переменной с клавиатуры, используется команда `read`.

```bash
$ cat script.sh
#!/bin/bash
read $userinput
echo "First arg: $1"
echo "Second arg: $2"
echo "User input: $userinput"
$ ./script.sh first second
hello
"First arg: first"
"Second arg: second"
"User input: hello"
```

## Условия

В bash допустимо использовать условные операторы. Условные операторы выглядят следующим образом.

```bash
#!/bin/bash

echo "Введите целое число:"
read number

if [ "$number" -gt 0 ]; then
    echo "Число $number положительное."
elif [ "$number" -lt 0 ]; then
    echo "Число $number отрицательное."
else
    echo "Число равно нулю."
fi
```

Более реальный пример работы с условиями -- проверка успешности выполнения команды

```bash
#!/bin/bash

cp source.txt destination.txt

if [ $? -eq 0 ]; then
    echo "Копирование файла выполнено успешно."
else
    echo "Ошибка при копировании файла."
fi
```

Можно строить более сложные условия. Например, добавим проверку на существование файла.

```bash
#!/bin/bash

SOURCE_FILE="source.txt"
DESTINATION_FILE="destination.txt"

if [ -f "$SOURCE_FILE" ]; then
    echo "Файл $SOURCE_FILE существует. Продолжаем копирование."

    cp "$SOURCE_FILE" "$DESTINATION_FILE"

    if [ $? -eq 0 ]; then
        echo "Копирование файла выполнено успешно."
    else
        echo "Ошибка при копировании файла."
    fi
else
    echo "Файл $SOURCE_FILE не существует. Операция копирования не может быть выполнена."
fi
```

## Циклы

В bash присутствует стандартный для любого языка программирования набор циклов: `for`, `while`, `util`

Цикл for предназначен для перебора элементов некоторого заданного множества. Он особенно полезен, когда нужно выполнить операции над списком известных элементов, например, файлами в директории или заданным диапазоном чисел.

```bash
for i in {1..99}; do
    echo user$i;
done
```

Или скопировать файл каждому пользователю в системе, для этого можно применить подставноку команд.

```bash
$file=/root/some_config.ini
for user in $(ls /home/): do
    cp $file /home/$user/
done
```

Цикл while выполняется до тех пор, пока истинно заданное условие. Он полезен, когда количество итераций заранее не известно и определяется в процессе выполнения.

При помощи цикла while можно заставить скрипт ожидать создания какого-либо файла

```bash
while [ ! -f /tmp/testfile ]
do
    echo "Waiting for file..."
    sleep 1
done
```

Цикл until работает точно так же, как while, но продолжает выполняться до тех пор, пока условие ложно. Это означает, что он будет выполнен хотя бы один раз, если условие изначально истинно.

Кроме того, bash поддерживает вложенные циклы, например для итерации по массиву чисел

```bash
for i in {1..3}
do
    for j in {1..2}
    do
        echo "i=$i, j=$j"
    done
done
```

## Итог

При помощи всех этих знаний можно писать довольно сложные скрипты. Попробуем написать инструмент мониторинга, который будет првоерять доступность url, успешные проверки записывать в файл success.txt, неудачные в errror.txt

```bash
#!/bin/bash

# Получаем URL из первого аргумента или запрашиваем у пользователя
if [ -z "$1" ]; then
    read -p "Введите URL для проверки: " url
else
    url=$1
fi

# Бесконечный цикл для проверки 3 раза в минуту
while true; do
    for i in {1..3}; do
        timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        
        # Выполняем запрос curl и извлекаем HTTP код ответа
        http_code=$(curl -o /dev/null -s -w "%{http_code}\n" "$url")

        # Проверяем код ответа
        if [ "$http_code" -eq 200 ]; then
            echo "$timestamp URL: $url Код: $http_code" >> success.txt
        else
            echo "$timestamp URL: $url Код: $http_code" >> error.txt
        fi
        
        sleep 20  # Ожидаем 20 секунд между проверками, чтобы проверять 3 раза в минуту
    done
done
```
